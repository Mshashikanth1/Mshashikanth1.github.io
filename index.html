<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PokÃ©mon RPG Resume Battle</title>
    <style>
        body {
          margin:0;
          overflow:hidden;
          background: radial-gradient(circle at 50% 50%, #0d0d1a 0%, #000 100%);
          font-family: 'Press Start 2P', monospace;
        }
        #battlefield {
          position:relative;
          height:100vh;
          display:flex;
          align-items:center;
          white-space:nowrap;
          overflow-x:auto;
          scroll-behavior:smooth;
          padding:0 50px;
          transition: all 0.5s ease; /* Smooth transition for layout changes */
        }
        .pokemon {
          position:relative;
          display:inline-flex;
          flex-direction:column;
          align-items:center;
          cursor:pointer;
          margin:0 15px;
          transition: transform 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* fun jump easing */
        }
        .pokemon img {
          width:125px;
          height:125px;
          object-fit:contain;
          image-rendering: pixelated;
          transition: transform 0.3s ease, width 0.5s ease, height 0.5s ease, opacity 0.2s ease-out; /* Smooth transition for size and opacity changes */
        }
        .dialog {
          position:absolute;
          bottom:100%;
          margin-bottom:25px; /* Increased margin to make space for the tail */
          background:white; /* Solid white background */
          color:black;
          padding:10px; /* Adjusted padding */
          border: 4px solid black; /* Dark, thick border */
          border-radius:4px; /* Slightly rounded corners */
          font-size:12px;
          white-space:normal;
          width:200px;
          text-align:center;
          opacity:0;
          pointer-events:none;
          transition: opacity 0.2s ease, width 0.5s ease, font-size 0.5s ease; /* Smooth transition for dialog changes */
          z-index:10;
          box-shadow: 8px 8px 0px rgba(0,0,0,0.5); /* Retro shadow effect */
        }
        .dialog::before {
          content: '';
          position: absolute;
          bottom: -12px; /* Position the tip of the arrow */
          left: 50%;
          transform: translateX(-50%);
          width: 0;
          height: 0;
          border-left: 12px solid transparent;
          border-right: 12px solid transparent;
          border-top: 12px solid black; /* Outer border of the arrow */
        }
        .dialog::after {
          content: '';
          position: absolute;
          bottom: -8px; /* Position the tip of the inner arrow */
          left: 50%;
          transform: translateX(-50%);
          width: 0;
          height: 0;
          border-left: 8px solid transparent;
          border-right: 8px solid transparent;
          border-top: 8px solid white; /* Inner fill of the arrow */
        }
        canvas {
          position:absolute;
          left:0;
          top:0;
          pointer-events:none;
          z-index:5;
        }

        @media (max-width: 768px) {
          #battlefield {
            padding: 0 20px; /* Adjust padding for smaller screens */
            align-items: center;
          }

          .pokemon {
            margin: 0 10px; /* Adjust margin for smaller screens */
          }

          .pokemon img {
            width: 90px; /* Slightly smaller */
            height: 90px;
          }

          .dialog {
            width: 180px; /* Slightly smaller */
            font-size: 11px;
          }
        }

        @media (max-width: 480px) {
          .pokemon img {
            width: 80px;
            height: 80px;
          }

          .dialog {
            width: 150px;
            font-size: 10px;
          }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://sfxr.me/riffwave.js"></script>
    <script src="https://sfxr.me/sfxr.js"></script>
</head>
<body>
<div id="battlefield"></div>
<canvas id="particles"></canvas>

<div id="pokemonDetailModal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:100;">
  <div style="background:white; margin:10% auto; padding:20px; border-radius:8px; width:80%; max-width:500px; color:black; position:relative;">
    <button id="closeModal" style="position:absolute; top:10px; right:10px; background:none; border:none; font-size:20px; cursor:pointer;">&times;</button>
    <h2 id="modalPokemonName" style="text-align:center;"></h2>
    <div style="text-align:center; margin-bottom:15px;">
      <img id="modalPokemonImage" src="" alt="Pokemon" style="width:150px; height:150px; object-fit:contain; image-rendering:pixelated;">
    </div>
    <p><strong>Types:</strong> <span id="modalPokemonTypes"></span></p>
    <p><strong>Abilities:</strong> <span id="modalPokemonAbilities"></span></p>
    <p><strong>Height:</strong> <span id="modalPokemonHeight"></span></p>
    <p><strong>Weight:</strong> <span id="modalPokemonWeight"></span></p>
  </div>
</div>

<script>
    const pokemonCount = 1025;
    const battlefield = document.getElementById('battlefield');
    const canvas = document.getElementById('particles');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    window.addEventListener('resize',()=>{canvas.width=window.innerWidth;canvas.height=window.innerHeight});

    // ===== Sound Effects =====


    const dialogSound = sfxr.toAudio(sfxr.generate("blipSelect"));

    // ===== Background Music =====
    const backgroundAudio = new Audio('https://raw.githubusercontent.com/Mshashikanth1/Mshashikanth1.github.io/main/backgroudAudio.mp3');
    backgroundAudio.loop = true;
    backgroundAudio.volume = 0.2; // Set a lower volume for background music
    
    let audioPlayed = false;
    document.addEventListener('click', () => {
        if (!audioPlayed) {
            backgroundAudio.play().then(() => {
                audioPlayed = true;
            }).catch(e => {
                console.error("Could not play background music on first interaction:", e);
            });
        }
    }, { once: true }); // Use { once: true } to ensure it only runs once

    backgroundAudio.addEventListener('error', (e) => {
        console.error("Error with audio element:", e);
        // Optionally, alert the user or display a message
    });

    const pokemonDetailModal = document.getElementById('pokemonDetailModal');
    const closeModalButton = document.getElementById('closeModal');
    const modalPokemonName = document.getElementById('modalPokemonName');
    const modalPokemonImage = document.getElementById('modalPokemonImage');
    const modalPokemonTypes = document.getElementById('modalPokemonTypes');
    const modalPokemonAbilities = document.getElementById('modalPokemonAbilities');
    const modalPokemonHeight = document.getElementById('modalPokemonHeight');
    const modalPokemonWeight = document.getElementById('modalPokemonWeight');

    closeModalButton.addEventListener('click', () => {
      pokemonDetailModal.style.display = 'none';
    });

    pokemonDetailModal.addEventListener('click', (event) => {
      if (event.target === pokemonDetailModal) {
        pokemonDetailModal.style.display = 'none';
      }
    });

    function showPokemonDetails(pokemonDiv) {
      modalPokemonName.textContent = pokemonDiv.dataset.name;
      modalPokemonImage.src = pokemonDiv.dataset.sprite1;
      modalPokemonTypes.textContent = pokemonDiv.dataset.types;
      modalPokemonAbilities.textContent = pokemonDiv.dataset.abilities || 'N/A';
      modalPokemonHeight.textContent = pokemonDiv.dataset.height ? `${pokemonDiv.dataset.height / 10} m` : 'N/A';
      modalPokemonWeight.textContent = pokemonDiv.dataset.weight ? `${pokemonDiv.dataset.weight / 10} kg` : 'N/A';
      pokemonDetailModal.style.display = 'block';
    }

    function handlePokemonClick(pokemonDiv) {
      const cryUrl = pokemonDiv.dataset.cry;
      if (cryUrl) {
        const audio = new Audio(cryUrl);
        audio.volume = 0.5; // Adjust volume as needed
        audio.play().catch(e => console.error("Error playing PokÃ©mon cry:", e));
      }
      showPokemonDetails(pokemonDiv);
    }

    // ===== Resume lines with anime-style emotion =====
    const achievements = [
      "Shashi forges backend services that scale to infinity and beyond ğŸš€.",
      "With Shashi at the helm, support tickets vanish like ghosts in the machine ğŸ‘».",
      "Shashi crafts dashboards so insightful, they reveal the future of data ğŸ”®.",
      "He automates pipelines with such grace, they flow like digital rivers ğŸŒŠ.",
      "Shashi's code boasts 99.9% uptime, a fortress of digital reliability ğŸ°.",
      "Refund and cashback logic bends to Shashiâ€™s will, 30% more efficient than before ğŸ’°.",
      "In the face of a data migration, Shashi's focus is a laser beam in the darkness ğŸ’¡.",
      "He whispers commands to chatbots, and they spring to life, ready for battle ğŸ¤–.",
      "For Shashi, a complex dashboard is a treasure map to untold business insights ğŸ—ºï¸.",
      "The CI/CD pipeline roars, a testament to Shashi's command over the digital domain ğŸ¦.",
      "Bugs dare not linger where Shashi's code resides, for he is the guardian of the system ğŸ›¡ï¸.",
      "Shashi orchestrates notifications with the precision of a master composer ğŸ¼.",
      "He tames the monstrous order processing system, making it a loyal beast of burden ğŸ².",
      "Late nights are but a training montage for Shashi, honing his skills to perfection âš”ï¸.",
      "Behind every seamless transaction is Shashi's epic struggle against chaos ğŸ’¥.",
      "Shashi leaps between data tables like a digital acrobat, a guardian of information ğŸ¤¸.",
      "He banishes bugs to the shadow realm, leaving systems pure and bright âœ¨.",
      "Shashi's recommendation engines are so accurate, they feel like mind-reading ğŸ§ .",
      "He migrates data by the hundred-thousands, a symphony of precision and order ğŸ¶.",
      "Cross-functional teams unite under Shashi's banner, achieving legendary release success ğŸ†.",
      "With CI/CD best practices, Shashi has tripled the speed of deployment, a true feat of engineering âš¡.",
      "The order lifecycle, once fraught with peril, is now a smooth journey thanks to Shashi â›µ.",
      "Shashi brings balance to the ledger, improving reconciliation accuracy by 40% âš–ï¸.",
      "His notification service handles 50,000 messages a day without breaking a sweat ğŸ’ª.",
      "Payment APIs under Shashi's watch are 20% faster, a blur of digital efficiency ğŸ’¨.",
      "Shashi's custom SuiteScripts have automated 70% of manual tasks, a magical feat of coding ğŸ§™.",
      "His dashboards are a beacon of clarity, revealing cost-cutting opportunities in the fog of finance ğŸŒ«ï¸.",
      "Business processes are 25% faster under Shashi's optimization, a true speed demon ğŸï¸.",
      "Shashi's grasp of modern architecture and caching is the stuff of legends ğŸ›ï¸.",
      "He models user interactions in Neo4j, revealing the secret heart of the system â¤ï¸.",
      "Recommendation accuracy is up by 30%, a testament to Shashi's data wizardry ğŸ§™â€â™‚ï¸.",
      "With caching, response times are down by 40%, a lightning-fast experience for all âš¡.",
    ];

    const resumeLines = [];
    for(let i=0;i<pokemonCount;i++){
      let line = achievements[i % achievements.length];
      const emotions = ["ğŸ˜Š","ğŸ”¥","ğŸ’¥","ğŸŒŸ","ğŸ’«","ğŸ’¦","ğŸŒ¸","âœ¨","ğŸ˜†","ğŸ¦„"];
      const emotion = emotions[Math.floor(Math.random()*emotions.length)];
      resumeLines.push(`${line} ${emotion}`);
    }

    // ===== Particle system =====
    let particles=[];
    function spawnParticles(x,y,type){

      for(let i=0;i<10;i++){
        particles.push({
          x,y,
          vx:(Math.random()-0.5)*4,
          vy:(Math.random()-1.5)*4,
          life:Math.random()*50+30,
          color:type==='Electric'?'#ffff33':
                type==='Fire'?'#ff5500':
                type==='Water'?'#33ccff':
                type==='Grass'?'#33ff55':'#fff'
        });
      }
    }
    function updateParticles(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      particles.forEach((p,i)=>{
        ctx.globalAlpha=p.life/60;
        ctx.fillStyle=p.color;
        ctx.beginPath();
        ctx.arc(p.x,p.y,3,0,Math.PI*2);
        ctx.fill();
        p.x+=p.vx;
        p.y+=p.vy;
        p.vy+=0.05;
        p.life--;
        if(p.life<=0) particles.splice(i,1);
      });
      requestAnimationFrame(updateParticles);
    }
    updateParticles();

    // ===== API Handling with Timeout =====
    function fetchWithTimeout(url, options, timeout = 5000) {
      return Promise.race([
        fetch(url, options),
        new Promise((_, reject) =>
          setTimeout(() => reject(new Error('timeout')), timeout)
        )
      ]);
    }

    // ===== Lazy load PokÃ©mon =====
    async function fetchPokemonData(index){
      try{
        const res = await fetchWithTimeout(`https://pokeapi.co/api/v2/pokemon/${index}`);
        const data = await res.json();
        
        let sprite, sprite2, animatedSprite;
        const versions = data.sprites.versions;
        const availableVersions = [];
        const allowedGens = ['generation-iii', 'generation-iv', 'generation-v', 'generation-vi', 'generation-vii', 'generation-viii'];

        if (versions) {
            for (const gen of allowedGens) {
                if (versions[gen]) {
                    for (const game in versions[gen]) {
                        if (versions[gen][game].front_default) {
                            availableVersions.push(versions[gen][game]);
                        }
                    }
                }
            }
        }

        if (availableVersions.length > 0) {
            const randomVersion = availableVersions[Math.floor(Math.random() * availableVersions.length)];
            sprite = randomVersion.front_default;
            sprite2 = randomVersion.back_default || data.sprites.back_default; // Fallback for back sprite
        } else {
            // Fallback to default sprites if no preferred version sprites are available
            sprite = data.sprites.front_default;
            sprite2 = data.sprites.back_default;
        }

        // Ensure we have a sprite, even if all else fails
        if (!sprite) {
            sprite = data.sprites.front_default;
        }

        // Get animated sprite
        if (data.sprites.versions['generation-v']['black-white'] && data.sprites.versions['generation-v']['black-white'].animated) {
            animatedSprite = data.sprites.versions['generation-v']['black-white'].animated.front_default;
        }

        const types = data.types.map(t=>t.type.name);
        const name = data.name;
        const cry = data.cries?.latest || data.cries?.legacy; // Get the cry URL, prioritizing 'latest'
        const abilities = data.abilities.map(a => a.ability.name).join(', ');
        const height = data.height;
        const weight = data.weight;
        return {sprite, sprite2, types, name, animatedSprite, cry, abilities, height, weight};
      }catch(e){
        console.error(`Failed to fetch pokemon ${index}:`, e);
        return null;
      }
    }

    // ===== Create PokÃ©mon elements =====
    function createPokemon(index){
      const div = document.createElement('div');
      div.className='pokemon';
      div.dataset.index=index;

      const img=document.createElement('img');
      div.appendChild(img);

      const dialog=document.createElement('div');
      dialog.className='dialog';
      div.appendChild(dialog);

      div.addEventListener('mouseenter',()=>showDialog(div));
      div.addEventListener('mouseleave',()=>hideDialog(div));
      div.addEventListener('click', () => handlePokemonClick(div));

      battlefield.appendChild(div);
      return div;
    }

    const pokemonDivs=[];
    for(let i=1;i<=pokemonCount;i++){
      pokemonDivs.push(createPokemon(i));
    }

    const observer=new IntersectionObserver(async(entries)=>{
      for(const entry of entries){
        if(entry.isIntersecting){
          const div=entry.target;
          const img=div.querySelector('img');
          if(!img.src){
            const data=await fetchPokemonData(div.dataset.index);
            if(data && data.sprite){
              img.src=data.sprite;
              div.dataset.sprite1=data.sprite;
              if(data.sprite2){
                div.dataset.sprite2=data.sprite2;
              }
              if (data.animatedSprite) {
                div.dataset.animated = data.animatedSprite;
              }
              if (data.cry) {
                div.dataset.cry = data.cry;
              }
              if (data.abilities) {
                div.dataset.abilities = data.abilities;
              }
              if (data.height) {
                div.dataset.height = data.height;
              }
              if (data.weight) {
                div.dataset.weight = data.weight;
              }
              div.dataset.types=data.types.join(',');
            }
          }
        }
      }
    },{root:null, rootMargin:'200px', threshold:0.1});
    pokemonDivs.forEach(div=>observer.observe(div));

    // ===== Dialog handling =====
    let lastLines=[];
    function getRandomResumeLine(){
      let line = resumeLines[Math.floor(Math.random()*resumeLines.length)];
      lastLines.push(line);
      if(lastLines.length>5) lastLines.shift();
      return line;
    }

    // ===== Jumping & speaking =====
    function speakRandomPokemon(){
      const available = pokemonDivs.filter(d=>d.querySelector('img').src);
      if(!available.length) return;

      const visiblePokemon = available.filter(poke => {
        const rect = poke.getBoundingClientRect();
        return rect.right > 0 && rect.left < window.innerWidth;
      });

      if (visiblePokemon.length === 0) {
        // No visible pokemon to make jump, so do nothing
        return;
      }

      // Pick only one visible pokemon
      const poke = visiblePokemon[Math.floor(Math.random() * visiblePokemon.length)];

      const dialog = poke.querySelector('.dialog');
      const line = getRandomResumeLine();
      dialog.textContent = line;
      dialog.style.opacity=1;

      // Random jump height
      const jumpHeight = Math.random()*80 + 40;
      poke.style.transform=`translateY(-${jumpHeight}px) scale(1.3)`;


      // Use animated sprite if available
      const img = poke.querySelector('img');
      if (poke.dataset.animated) {
        img.src = poke.dataset.animated;
      }

      const rect = poke.getBoundingClientRect();
      const type = poke.dataset.types?.split(',')[0] || 'Electric';
      spawnParticles(rect.left+40, rect.top+40,type);

      setTimeout(()=>{
        dialog.style.opacity=0;
        poke.style.transform='translateY(0) scale(1)';
        // Revert to static sprite
        if (poke.dataset.sprite1) {
            img.src = poke.dataset.sprite1;
        }
      },3000);
    }

    // Hover dialog
    function showDialog(poke){
      const dialog = poke.querySelector('.dialog');
      dialog.textContent=getRandomResumeLine();
      dialog.style.opacity=1;
      dialogSound.play();
      const jumpHeight = Math.random()*60 + 30;
      poke.style.transform=`translateY(-${jumpHeight}px) scale(1.2)`;

      
      // Use animated sprite if available
      const img = poke.querySelector('img');
      if (poke.dataset.animated) {
        img.src = poke.dataset.animated;
      }

      const rect = poke.getBoundingClientRect();
      const type = poke.dataset.types?.split(',')[0] || 'Electric';
      spawnParticles(rect.left+40, rect.top+40,type);
    }
    function hideDialog(poke){
      poke.querySelector('.dialog').style.opacity=0;
      poke.style.transform='translateY(0) scale(1)';
      
      // Revert to static sprite
      const img = poke.querySelector('img');
      if (poke.dataset.sprite1) {
        img.src = poke.dataset.sprite1;
      }
    }

    // ===== Loops & Scrolling =====
    setInterval(speakRandomPokemon,1200); // more frequent
    
    let scrollDirection = -1; // Start scrolling right to left
    let autoScrollEnabled = true;

    function autoScroll(){
      if (autoScrollEnabled) {
        battlefield.scrollLeft += scrollDirection * 2; // faster scroll
        if(battlefield.scrollLeft >= battlefield.scrollWidth - window.innerWidth -1) {
            scrollDirection = -1;
        } else if (battlefield.scrollLeft <= 0) {
            scrollDirection = 1;
        }
      }
      requestAnimationFrame(autoScroll);
    }
    autoScroll();

    battlefield.addEventListener('wheel', (e) => {
        e.preventDefault();
        battlefield.scrollLeft += e.deltaY;
        autoScrollEnabled = false; // Disable auto-scroll on user interaction
        setTimeout(() => autoScrollEnabled = true, 5000); // Re-enable after 5s of inactivity
    });
</script>
</body>
</html>
